# 후위 계산법

# 후위 표기법에 대해 잘못 알고 있었다.

# A = 1, B = 2, C = 3, D = 4
# A+B-C*D = -9
# 라면 정말 순서대로 AB+CD*-가 되어야한다.
# 그래야 다시 중위 표기를 할떄
# A+BCD*- -> A+BC*D- -> A+B-C*D가 된다.

# 고로 먼저 나오는 숫자는 당연히
# 맨 앞으로 붙여준다.

# 먼저 들어가 있는 사칙연산이 만약 새로 들어온 사칙연산이랑 우선 순위가 같다면
# 바로 뺴서 계산 해준다.

# ex) A+B+C+D+F = AB+C+D+F+ 이런식으로 된다.
# 곱셈도 마찬가지다

# 하지만 덧셈과 뺄셈의 경우에는 동위가 아니라 괄호가 시작된 식이 아니라면 무조건 빼줘야한다.
# A+B+C 가 ABC++이 될수 없다 이유는
# 다시 중위로 바꾼다면 B+C+A 순서이므로 안된다.

# 하지만 먼저 들어가 있는 사칙연산이 만약 새로 들어오려는 사칙연산보다 우선 순위가 높다면
# 우리는 앞에서 붙여 놓은 숫자를 미리 계산 해줘야한다.

# ex) A*B+C => AB , * 가 형성이 되고
# +가 들어오려 할떄 이미 *가 대기 하고 있고 먼저 들어가 있는 *가 +보다 우선 순위가 높아
# *를 꺼내와 붙여준다 AB*, +
# 그리고 C를 붙인 뒤 마지막 연산을 붙여주면 된다.

# 하지만 반대 상황이라면
# ex) A+B*C => AB, +
# 이렇게 되어있다면 *가 들어와도 어차피 *를 먼저 할 것이기 떄문에 대기한다.
# 그러면 AB, [+, *]
# 이제 C가 들어오면 자연스럽게 붙여주고
# ABC가 되고 사칙연산 스택에서 pop으로 꺼내와 붙여준다.

# 만약 괄호가 존재한다면
# 괄호 먼저 넣고 나서 뒤를 생각해야한다.

# 괄호가 들어오고나서
# 만약 + 기호가 들어온다면
# 원래는 바로 앞에 있는 사칙연산을 먼저 바로 계산을 해주어야하는데
# 바로 앞에 들어간것이 사칙연산이 아닌 열린 괄호라면
# 일단 해당 연산도 넣어 주어야한다.

# 하지만 괄호가 들어오고 나서
# *가 들어온 경우
# 맨 끝이 *이거나 /일때만 미리 추가이고 +, -인 우선 순위가 낮은 애들은 뒤에 붙기 때문에 그냥 바로 넣어줘야한다.

# 이게 설명만으로는 어렵다 심지어 이렇게 간단한 코드가 존재한다는게 대단하다..

# 솔직히 대충 예시를 들어서는 이해가 갔지만 제대로 설명은 어렵다..


inlst = input()
lst = []
ans = ''
for i in inlst:
    # 괄호는 무조건 넣어줌
    if i == '(':
        lst.append(i)
    # 닫는 괄호가 나온다면
    elif i == ')':
        # 닫는 괄호가 나왔다면 연 괄호가 있을테니 연괄호 전까지 연산을 수행 해주어야한다.
        # 연산 수행을 다 마치고 마지막 번지가 연괄호가 나온다면 연산이 끝났다
        while len(lst) > 0 and lst[-1] != '(':
            ans += lst.pop()
        # 연괄호도 빼준다.
        lst.pop()
    # 만약 곱셈이나 나눗셈이 나왔다면
    elif i == '*' or i == '/':
        # 마지막이 곱셈과 나눗셈이 있다면
        # 앞에서 연산한것에 곱셈 또는 나눗셈을 먼저 해준다.
        while len(lst) > 0 and (lst[-1] == '*' or lst[-1] == '/'):
            ans += lst.pop()
        # 그리고 지금 나온 곱셈 or 나눗셈은 넣어줌
        lst.append(i)
    # 만약 덧셈, 뺄셈이 나왔다면
    elif i == '+' or i == '-':
        # 마지막이 열린 괄호가 아니라면
        # 후위계산법에 의해 덧셈, 뺄셈전에는 어떠한 사칙연산이 있던간에 무조건 선계산을 해줘야한다 그래야 순서가 맞아 떨어진다.
        while len(lst) > 0 and lst[-1] != '(':
            ans += lst.pop()
        # 하지만 마지막이 열린 괄호라면 일단 사칙연산 순서를 정해야하므로 넣어줌
        lst.append(i)
    # 사칙 연산이 아닌 것들은 그냥 무조건 맨 왼쪽부터 채우면 된다
    else:
        ans += i
# 다 끝나고 나서 남은 연산을 붙여준다.
while lst:
    ans += lst.pop()
print(ans)